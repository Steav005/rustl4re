#![recursion_limit="128"]
extern crate proc_macro;
extern crate proc_macro2;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn::{self, Attribute, Data, Fields, Generics, Lit, Meta, Visibility};

#[proc_macro_attribute]
pub fn l4_callable(macro_attrs: TokenStream, item: TokenStream) -> TokenStream {
    let demand = match macro_attrs.is_empty() {
        true => 0,
        false => {
            let name_val: syn::MetaNameValue = match syn::parse(macro_attrs)
                    .expect("Broken attribute specification") {
                Meta::NameValue(nv) => nv,
                _ => panic!("You must specify demand = <num>"),
            };
            if name_val.ident != "demand" {
                panic!("Unrecognised macro attribute, try \"demand\"");
            }
            match name_val.lit {
                Lit::Int(l) => l.value(),
                _ => panic!("`demand` must be specified as a positive integer")
            }
        }
    };

    let ast: syn::DeriveInput = syn::parse(item).expect("Unable to parse struct definition.");
    let structdef = match ast.data {
        Data::Struct(ds) => ds,
        _ => panic!("This attribute can only be used on structs"),
    };
    let name = ast.ident;
    match structdef.fields {
        Fields::Named(_) => gen_named_struct(name, ast.attrs, ast.vis,
                                             ast.generics, structdef.fields,
                                             demand),
        Fields::Unnamed(_) => panic!("Only named structs or unnamed structs \
                can be turned into an IPC server."),
        Fields::Unit => gen_unit_struct(name.into(), ast.attrs, ast.vis,
                                        ast.generics, demand),
    }
}

fn gen_named_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, fields: Fields,
                    demand: u64)
                    -> proc_macro::TokenStream {
    // duplicate names and types of fields, because quote! moves them
    let initialiser_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_types: Vec<_> = fields.iter().map(|f| f.ty.clone()).collect();
    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback,
            #(#fields),*
        }

        impl #name {
            fn new(#(#arg_names: #arg_types),*) -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>,
                    #(
                        #initialiser_names
                    ),*
                }
            }
        }
        impl crate::l4::ipc::types::Demand for #name {
            const BUFFER_DEMAND: u32 = #demand as u32;
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }
    };
    gen.into()
}

fn gen_unit_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, demand: u64)
                -> proc_macro::TokenStream {
    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback
        }

        impl #name {
            fn new() -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>
                }
            }
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }
        impl crate::l4::ipc::types::Demand for #name {
            const BUFFER_DEMAND: u32 = #demand as u32;
        }
        impl crate::l4::ipc::types::Dispatch for #name {
            fn dispatch(&mut self, tag: MsgTag, u: *mut l4_utcb_t) -> Result<MsgTag> {
                self.op_dispatch(tag, u) // auto-generated by iface! macro
            }
        }
    };
    gen.into()
}
