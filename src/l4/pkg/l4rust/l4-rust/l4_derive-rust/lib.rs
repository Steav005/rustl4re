extern crate proc_macro;
extern crate proc_macro2;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn::{self, Attribute, Data, Fields, Generics, Visibility};

#[proc_macro_attribute]
pub fn l4_callable(_a: TokenStream, item: TokenStream) -> TokenStream {
    let ast: syn::DeriveInput = syn::parse(item).expect("Unable to parse struct definition.");
    let structdef = match ast.data {
        Data::Struct(ds) => ds,
        _ => panic!("This attribute can only be used on structs"),
    };
    let name = ast.ident;
    match structdef.fields {
        Fields::Named(_) => gen_named_struct(name, ast.attrs, ast.vis,
                                             ast.generics, structdef.fields),
        Fields::Unnamed(_) => panic!("Only named structs or unnamed structs \
                can be turned into an IPC server."),
        Fields::Unit => gen_unit_struct(name.into(), ast.attrs, ast.vis, ast.generics),
    }
}

fn gen_named_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, fields: Fields)
                    -> proc_macro::TokenStream {
    // duplicate names and types of fields, because quote! moves them
    let initialiser_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_types: Vec<_> = fields.iter().map(|f| f.ty.clone()).collect();
    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback,
            #(#fields),*
        }

        impl #name {
            fn new(#(#arg_names: #arg_types),*) -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>,
                    #(
                        #initialiser_names
                    ),*
                }
            }
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }
    };
    gen.into()
}

fn gen_unit_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics,)
                -> proc_macro::TokenStream {
    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback
        }

        impl #name {
            fn new() -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>
                }
            }
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }

        impl crate::l4::ipc::types::Dispatch for #name {
            fn dispatch(&mut self, tag: MsgTag, u: *mut l4_utcb_t) -> Result<MsgTag> {
                self.op_dispatch(tag, u) // auto-generated by iface! macro
            }
        }
    };
    gen.into()
}
