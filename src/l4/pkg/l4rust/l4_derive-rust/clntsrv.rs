//! attributes to generate client and server implementations
use proc_macro::TokenStream;
use quote::quote;
use syn::{Attribute, Fields, Generics, Ident, Lit, Meta, NestedMeta,
        Result, Visibility};
use syn::spanned::Spanned;
use std::str::FromStr;

pub fn gen_server_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, fields: Fields,
                    demand: u32)
                    -> proc_macro::TokenStream {
    // duplicate names and types of fields, because quote! moves them
    let initialiser_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_types: Vec<_> = fields.iter().map(|f| f.ty.clone()).collect();

    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback,
            __cap: crate::l4::cap::CapIdx,
            #(#fields),*
        }

        impl #name {
            /// Create a new #name instance
            ///
            /// The first argument is the IPC gate that this server is bound to.
            /// For example: `#name::new(my_cap, #(#arg_names),*)`.
            fn new(cap: l4::cap::CapIdx, #(#arg_names: #arg_types),*) -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>,
                    __cap: cap,
                    #(
                        #initialiser_names
                    ),*
                }
            }
        }
        impl crate::l4::ipc::types::Demand for #name {
            const BUFFER_DEMAND: u32 = #demand;
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }
        impl crate::l4::ipc::types::Dispatch for #name {
            #[inline]
            fn dispatch(&mut self, tag: crate::l4::ipc::MsgTag,
                        mr: &mut l4::utcb::UtcbMr,
                        bufs: &mut l4::ipc::BufferAccess)
                    -> crate::l4::error::Result<crate::l4::ipc::MsgTag> {
                // op_dispatch is auto-generated by the iface! macro
                self.op_dispatch(tag, mr, bufs)
            }
        }
        impl l4::cap::Interface for #name {
            unsafe fn cap(&self) -> l4::cap::CapIdx {
                self.__cap
            }
        }
        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                panic!("Not implemented for servers");
            }
        }
    };
    gen.into()
}

pub fn parse_client_meta(meta: syn::AttributeArgs) -> Result<(Ident, u32)> {
    let mut traitname = None;
    let mut demand = 0;
    for item in meta {
        let item = match item {
            NestedMeta::Meta(m) => m,
            NestedMeta::Literal(l) => err!(l, "Literals not allowed"),
        };
        match item {
            Meta::Word(tn) => traitname = Some(tn),
            Meta::NameValue(nv) => {
                if nv.ident != "demand" {
                    err!(nv.ident, "Only `demand = NUM` allowed");
                }
                demand = match nv.lit {
                    Lit::Int(i) => i.value() as u32,
                    _ => err!(nv.ident, "Demand can only be a positive integer number"),
                };
            },
            Meta::List(ml) => err!(ml, "Invalid nesting of attributes"),
        };
    }
    if traitname.is_none() {
        err!("No IPC interface trait specified");
    }
    Ok((traitname.unwrap(), demand))
}

pub fn gen_client_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, trait_name: Ident,
                    demand: u32)
                -> proc_macro::TokenStream {
    let slot_type: syn::Type = match demand {
        0 => syn::parse(TokenStream::from_str("l4::ipc::Bufferless").unwrap()).unwrap(),
        _ => syn::parse(TokenStream::from_str("l4::ipc::BufferManager").unwrap()).unwrap()
    };
    let gen = quote! {
        #(#attrs)*
        #vis struct #name #generics {
            __cap: crate::l4::cap::CapIdx,
            __slots: #slot_type,
        }

        impl crate::l4::cap::Interface for #name {
            unsafe fn cap(&self) -> crate::l4::cap::CapIdx {
                self.__cap
            }
        }
        impl crate::l4::cap::IfaceInit for #name {
            fn new(c: crate::l4::cap::CapIdx) -> Self {
                #name {
                    __cap: c,
                    __slots: <#slot_type as l4::ipc::CapProvider>::new(),
                }
            }
        }
        impl #trait_name for #name { }

        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                use l4::ipc::CapProvider;
                self.__slots.access_buffers()
            }
        }
    };
    gen.into()
}
